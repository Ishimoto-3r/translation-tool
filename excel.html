<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Excel翻訳</title>

  <!-- Tailwind（既存ツールと同一の見た目） -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- 書式保持編集用：xlsx-populate -->
  <script src="https://unpkg.com/xlsx-populate/browser/xlsx-populate.min.js"></script>

  <style>
    /* 他ツールと同じナビ体裁（最低限） */
    .tool-nav a { padding:6px 10px; border-radius:8px; }
    .tool-nav a.active, .tool-nav a:hover { background:#111827; color:#fff; }
    /* 簡易モーダル */
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:50; }
    .modal { width: 520px; max-width:calc(100vw - 2rem); }
  </style>
</head>
<body class="bg-gray-50 text-gray-800">
  <!-- ヘッダー（他ページと完全一致構造） -->
  <header class="border-b bg-white">
    <div class="mx-auto max-w-6xl px-4 py-4 flex items-center justify-between">
      <h1 class="text-xl font-semibold">Excel翻訳</h1>
      <nav class="tool-nav flex gap-3 text-sm">
        <a href="/index.html">翻訳ツール</a>
        <a href="/report.html">修理レポート</a>
        <a href="/excel.html" class="active">Excel翻訳</a>
      </nav>
    </div>
  </header>

  <main class="mx-auto max-w-6xl px-4 py-6 space-y-6">
    <!-- 1) ファイルを開く -->
    <section class="rounded-2xl border bg-white p-4 shadow-sm">
      <h2 class="mb-3 text-lg font-medium">1) 「検証結果」ファイルを開く</h2>
      <div class="flex flex-wrap items-center gap-3">
        <input id="fileInput" type="file" accept=".xlsx" class="block text-sm" />
        <span id="fileName" class="text-sm text-gray-600">未選択</span>
      </div>
      <p class="mt-2 text-xs text-gray-500">※ .xlsx を選択してください（先頭シートを対象）。</p>
      <p id="status" class="mt-1 text-xs text-gray-500">ファイル未選択</p>
    </section>

    <!-- 2) 指定列 翻訳 -->
    <section class="rounded-2xl border bg-white p-4 shadow-sm">
      <h2 class="mb-3 text-lg font-medium">2) 指定列を翻訳</h2>
      <div class="grid grid-cols-1 gap-3 md:grid-cols-2">
        <div class="grid grid-cols-2 items-center gap-2">
          <label class="text-xs">対象列（A,B,C... 空=最右列）</label>
          <input id="sourceCol" type="text" class="rounded border px-2 py-1 text-sm" placeholder="例: C"/>
          <label class="text-xs">見出し行</label>
          <input id="headerRow" type="number" min="1" value="5" class="rounded border px-2 py-1 text-sm"/>
          <label class="text-xs">処理開始行</label>
          <input id="startRow" type="number" min="1" value="6" class="rounded border px-2 py-1 text-sm"/>
          <label class="text-xs">出力列の見出し</label>
          <input id="outHeader" type="text" value="翻訳" class="rounded border px-2 py-1 text-sm"/>
          <label class="text-xs">翻訳言語</label>
          <select id="lang" class="rounded border px-2 py-1 text-sm">
            <option value="ja">日本語</option>
            <option value="zh">中国語</option>
            <option value="en">英語</option>
            <option value="ko">韓国語</option>
          </select>
        </div>
        <div class="flex items-end gap-2">
          <button id="runBtn"  type="button" class="rounded bg-indigo-600 px-3 py-2 text-sm text-white">確認して実行</button>
          <button id="saveAsBtn" type="button" class="rounded border px-3 py-2 text-sm" disabled>別名で保存</button>
        </div>
      </div>
      <p class="mt-2 text-xs text-gray-500">※ 改行は一時的に <code>|||</code> で保護→復元。翻訳APIは <code>/api/excel-translate</code> を利用（MOCKなし）。</p>
    </section>
  </main>

  <!-- 保存名入力モーダル -->
  <div id="saveModal" class="modal-backdrop">
    <div class="modal rounded-2xl border bg-white p-4 shadow-xl">
      <h3 class="text-base font-semibold mb-2">別名で保存</h3>
      <label class="text-xs text-gray-600 block mb-1">保存ファイル名（拡張子 .xlsx）</label>
      <input id="saveName" type="text" class="w-full rounded border px-2 py-1 text-sm" />
      <div class="mt-4 flex justify-end gap-2">
        <button id="cancelSave" class="rounded border px-3 py-1 text-sm">キャンセル</button>
        <button id="confirmSave" class="rounded bg-indigo-600 px-3 py-1 text-sm text-white">保存</button>
      </div>
    </div>
  </div>

  <script>
    // ---------- 状態 ----------
    let workbook = null;        // xlsx-populate Workbook
    let ws = null;              // 対象シート（先頭）
    let fileName = "";          // 元ファイル名
    let pendingBlob = null;     // 保存待ちの結果

    const $ = (id) => document.getElementById(id);
    const fileInput = $("fileInput");
    const fileNameEl = $("fileName");
    const statusEl = $("status");
    const runBtn = $("runBtn");
    const saveAsBtn = $("saveAsBtn");

    const saveModal = $("saveModal");
    const saveName = $("saveName");
    const cancelSave = $("cancelSave");
    const confirmSave = $("confirmSave");

    function setStatus(t){ statusEl.textContent = t; }

    function colLetterToNumber(str){
      // A->1 (1基準)
      str = (str||"").trim().toUpperCase();
      if(!str) return null;
      let n=0;
      for(let i=0;i<str.length;i++){ n = n*26 + (str.charCodeAt(i)-64); }
      return n;
    }
    function numberToColLetter(n){
      // 1->A
      let s=""; while(n>0){ const m=(n-1)%26; s=String.fromCharCode(65+m)+s; n=Math.floor((n-1)/26); }
      return s;
    }

    function openModal(defaultName){
      saveName.value = defaultName;
      saveModal.style.display = "flex";
      saveName.focus();
      saveName.select();
    }
    function closeModal(){ saveModal.style.display = "none"; }

    // ---- ファイル選択 → 読み込み ----
    fileInput.addEventListener("change", async (e)=>{
      try{
        const f = e.target.files?.[0];
        if(!f) return;
        fileName = f.name || "";
        fileNameEl.textContent = fileName || "未選択";
        setStatus("読み込み中…");

        const buf = await f.arrayBuffer();
        workbook = await XlsxPopulate.fromDataAsync(buf);
        ws = workbook.sheet(0); // 先頭シート
        setStatus(`開きました：${fileName}（シート: ${ws.name()}）`);
        saveAsBtn.disabled = true;
        pendingBlob = null;
      }catch(err){
        console.error(err);
        setStatus("エラー：ファイルの読み込みに失敗しました（.xlsx を指定）");
      }
    });

    // ---- 書式コピー（代表的な項目を移送）----
    function copyCellStyle(src, dst){
      const keys = [
        "bold","italic","underline","strikethrough",
        "fontColor","fontFamily","fontSize",
        "horizontalAlignment","verticalAlignment",
        "wrapText","shrinkToFit","textRotation",
        "fill","numberFormat"
      ];
      keys.forEach(k=>{
        try{ const v = src.style(k); if(v !== undefined) dst.style(k, v); }catch(_){}
      });
      ["top","left","bottom","right"].forEach(side=>{
        try{
          const cap = side.charAt(0).toUpperCase()+side.slice(1);
          const b = src.style("border"+cap);
          if(b) dst.style("border"+cap, b);
        }catch(_){}
      });
    }

    // ---- 翻訳API（配列→配列、MOCKなし）----
    async function fetchTranslations(texts, toLang){
      const CHUNK = 300;
      const result = [];
      for(let i=0;i<texts.length;i+=CHUNK){
        const chunk = texts.slice(i,i+CHUNK);
        const res = await fetch("/api/excel-translate",{
          method:"POST",
          headers:{"Content-Type":"application/json"},
          body: JSON.stringify({ rows: chunk, fromLang: null, toLang })
        });
        if(!res.ok){
          const t = await res.text();
          throw new Error("翻訳APIエラー: " + t);
        }
        const json = await res.json();
        if(!Array.isArray(json.translations) || json.translations.length !== chunk.length){
          throw new Error("翻訳結果の長さ不一致");
        }
        result.push(...json.translations);
        setStatus(`翻訳中… ${Math.min(i+CHUNK,texts.length)} / ${texts.length}`);
      }
      return result;
    }

    // ---- 実行 ----
    runBtn.addEventListener("click", async ()=>{
      try{
        if(!workbook || !ws){ alert("先にExcelファイルを選択してください"); return; }

        const lang = document.getElementById("lang").value;
        const headerRow = parseInt(document.getElementById("headerRow").value,10) || 5;
        const startRow  = parseInt(document.getElementById("startRow").value,10)  || 6;
        const outHeader = document.getElementById("outHeader").value || "翻訳";
        const srcColStr = (document.getElementById("sourceCol").value || "").trim().toUpperCase();

        // 使用範囲を取得
        const usedRange = ws.usedRange();
        const lastRow   = usedRange.endCell().rowNumber();
        const lastCol   = usedRange.endCell().columnNumber();

        let srcCol = srcColStr ? colLetterToNumber(srcColStr) : lastCol; // 1基準
        if(!srcCol || srcCol<1) srcCol = lastCol;

        const srcColLetter = numberToColLetter(srcCol);
        const outCol       = srcCol + 1;
        const outColLetter = numberToColLetter(outCol);

        const msg = `指定列 ${srcColLetter} を ${lang} に翻訳して ${outColLetter} 列へ出力します。よろしいですか？`;
        if(!confirm(msg)) return;

        // 見出しセルと列幅コピー
        const srcHeaderCell = ws.cell(headerRow, srcCol);
        const outHeaderCell = ws.cell(headerRow, outCol).value(outHeader);
        copyCellStyle(srcHeaderCell, outHeaderCell);
        try{
          const w = ws.column(srcCol).width();
          if(typeof w === "number") ws.column(outCol).width(w);
        }catch(_){}

        // 入力抽出（改行保護）
        const SPECIAL = "|||";
        const inputs = [];
        const rowMap = [];
        for(let r = startRow; r <= lastRow; r++){
          const v = ws.cell(r, srcCol).value();
          const s = (v===undefined || v===null) ? "" : String(v);
          if(s !== ""){
            inputs.push(s.replace(/\n/g, SPECIAL));
            rowMap.push(r);
          }
        }
        if(inputs.length === 0){ alert("翻訳対象テキストがありません"); return; }

        setStatus(`翻訳中… (${inputs.length} 件)`);
        const translations = await fetchTranslations(inputs, lang);

        // 反映（値だけ置換・書式は元セルからコピー）
        for(let i=0;i<rowMap.length;i++){
          const r = rowMap[i];
          const srcCell = ws.cell(r, srcCol);
          const dstCell = ws.cell(r, outCol);
          const text = translations[i].replaceAll(SPECIAL, "\n");
          dstCell.value(text);
          copyCellStyle(srcCell, dstCell);
        }

        // 結果をメモリへ（上書きせず、別名保存待ちにする）
        const outBuffer = await workbook.outputAsync(); // ArrayBuffer
        pendingBlob = new Blob([outBuffer], {
          type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        });
        saveAsBtn.disabled = false;

        // 保存名のデフォルト（元ファイル名_翻訳.xlsx）
        const base = fileName ? fileName.replace(/\.xlsx$/i, "") : "検証結果";
        openModal(`${base}_翻訳.xlsx`);

        setStatus("完了：結果をメモリに保持しました。保存名と保存先を指定してください。");
      }catch(e){
        console.error(e);
        setStatus("エラー：翻訳処理に失敗しました");
        alert(e.message || "翻訳中にエラーが発生しました。");
      }
    });

    // ---- 別名で保存（モーダル）----
    cancelSave.addEventListener("click", ()=> closeModal());
    saveAsBtn.addEventListener("click", ()=>{
      const base = fileName ? fileName.replace(/\.xlsx$/i, "") : "検証結果";
      openModal(`${base}_翻訳.xlsx`);
    });

    confirmSave.addEventListener("click", async ()=>{
      try{
        if(!pendingBlob){ alert("保存できる内容がありません。先に翻訳を実行してください。"); return; }
        let name = (saveName.value || "").trim();
        if(!name) name = "検証結果_翻訳.xlsx";
        if(!/\.xlsx$/i.test(name)) name += ".xlsx";

        // 1) File System Access API があれば、完全な保存ダイアログ
        if(window.showSaveFilePicker){
          const handle = await showSaveFilePicker({
            suggestedName: name,
            types: [{
              description: "Excel",
              accept: { "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [".xlsx"] }
            }]
          });
          const writable = await handle.createWritable();
          await writable.write(pendingBlob);
          await writable.close();
          closeModal();
          setStatus("保存しました。");
          return;
        }

        // 2) フォールバック：通常ダウンロード（ブラウザ設定により保存先ダイアログが出ます）
        const url = URL.createObjectURL(pendingBlob);
        const a = document.createElement("a");
        a.href = url;
        a.download = name;  // ここでファイル名を指定
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        closeModal();
        setStatus("ダウンロードを開始しました。（保存先はブラウザの設定に依存）");
      }catch(e){
        console.error(e);
        alert(e.message || "保存に失敗しました。");
      }
    });
  </script>
</body>
</html>
